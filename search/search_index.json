{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pycommons-lang","text":"<p>Python Commons Lang package inspired by Apache Commons Lang available in Java. Along with the utilities, mirroring Apache Commons Lang, this library also provides additional language features borrowed from Java that can be used in Python like Streams, Consumer, Predicates, Optional etc.</p> <p>Visit the documentation to view the usage of each and every class and feature provided by this library.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>To get started with this library, you can install this in your virtual environment by running</p> <pre><code>pip install pycommons-lang\n</code></pre> <p>With poetry, you can run the following command to add the library to your project</p> <pre><code>poetry add pycommons-lang\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Apache-2.0 (See License)</p>"},{"location":"#author","title":"Author","text":"<p>Shashank Sharma.</p>"},{"location":"package/booleanutils/","title":"booleanutils","text":""},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils","title":"<code> BooleanUtils            (UtilityClass)         </code>","text":"<p>BooleanUtils class that provides helper methods to operate on boolean values that mirrors the features provided by the Apache Commons Lang's BooleanUtils class</p> <p>References</p> <p>https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/BooleanUtils.html</p> Source code in <code>lang/booleanutils.py</code> <pre><code>class BooleanUtils(UtilityClass):\n\"\"\"\n    BooleanUtils class that provides helper methods to operate on boolean values that mirrors the\n    features provided by the Apache Commons Lang's BooleanUtils class\n\n    References:\n        https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/BooleanUtils.html\n    \"\"\"\n\n    TRUE: ClassVar[str] = str(True).lower()\n\"\"\"\n    The \"true\" string\n    \"\"\"\n    FALSE: ClassVar[str] = str(False).lower()\n\"\"\"\n    The \"false\" string\n    \"\"\"\n\n    T: ClassVar[str] = \"t\"\n\"\"\"\n    The \"t\" string\n    \"\"\"\n    F: ClassVar[str] = \"f\"\n\"\"\"\n    The \"f\" string\n    \"\"\"\n\n    YES: ClassVar[str] = \"yes\"\n\"\"\"\n    The \"yes\" string\n    \"\"\"\n    NO: ClassVar[str] = \"no\"\n\"\"\"\n    The \"no\" string\n    \"\"\"\n\n    Y: ClassVar[str] = \"y\"\n\"\"\"\n    The \"y\" string\n    \"\"\"\n    N: ClassVar[str] = \"n\"\n\"\"\"\n    The \"n\" string\n    \"\"\"\n\n    OFF: ClassVar[str] = \"off\"\n\"\"\"\n    The \"off\" string\n    \"\"\"\n    ON: ClassVar[str] = \"on\"\n\"\"\"\n    The \"on\" string\n    \"\"\"\n\n    @classmethod\n    def and_args(cls, *args: bool) -&gt; bool:\n\"\"\"\n        Performs `and` operation on all the arguments and returns the result\n        Args:\n            *args: Boolean Arguments\n\n        Returns:\n            True if all the arguments are True, False otherwise\n        \"\"\"\n        ArrayUtils.require_not_empty(args)\n        for flag in args:\n            ObjectUtils.require_not_none(flag)\n            if cls.is_not_true(flag):\n                return False\n\n        return True\n\n    @classmethod\n    def or_args(cls, *args: bool) -&gt; bool:\n\"\"\"\n        Performs `or` operation on all the arguments and returns the result\n        Args:\n            *args: Boolean Arguments\n\n        Returns:\n            True if any of the arguments are True, False otherwise\n        \"\"\"\n        ArrayUtils.require_not_empty(args)\n        for flag in args:\n            ObjectUtils.require_not_none(flag)\n            if flag:\n                return True\n\n        return False\n\n    @classmethod\n    def compare(cls, x: bool, y: bool) -&gt; int:\n        if x == y:\n            return 0\n        if (not x) and y:\n            return -1\n        # x and (not y)\n        return 1\n\n    @classmethod\n    def is_false(cls, flag: Optional[bool]) -&gt; bool:\n\"\"\"\n        Return if an optional flag is `False` by handling `None` as False\n        Args:\n            flag: A boolean object or None\n\n        Returns:\n            True if the flag is False, False otherwise\n        \"\"\"\n        return flag is False\n\n    @classmethod\n    def is_not_false(cls, flag: Optional[bool]) -&gt; bool:\n\"\"\"\n        Negation of [`is_false`][pycommons.lang.booleanutils.BooleanUtils.is_false]\n        method by handling `None` as False\n        Args:\n            flag: A boolean flag or None\n\n        Returns:\n            True if the flag is not False, False otherwise\n        \"\"\"\n        return flag is not False\n\n    @classmethod\n    def is_true(cls, flag: Optional[bool]) -&gt; bool:\n\"\"\"\n        Return if an optional flag is `True` by handling `None` as False\n        Args:\n            flag: A boolean object or None\n\n        Returns:\n            True if the flag is True, False otherwise\n        \"\"\"\n        return flag is True\n\n    @classmethod\n    def is_not_true(cls, flag: Optional[bool]) -&gt; bool:\n\"\"\"\n        Negation of [`is_false`][pycommons.lang.booleanutils.BooleanUtils.is_true]\n        method by handling `None` as False\n        Args:\n            flag: A boolean flag or None\n\n        Returns:\n            True if the flag is not True, False otherwise\n        \"\"\"\n        return flag is not True\n\n    @classmethod\n    def negate(cls, flag: Optional[bool]) -&gt; Optional[bool]:\n\"\"\"\n        Negate a boolean by returning `None` for `None`.\n        Args:\n            flag: A boolean flag or None\n\n        Returns:\n            True if False, False if True, None if None\n        \"\"\"\n        if flag is None:\n            return None\n        return not flag\n\n    @classmethod\n    @overload\n    def to_boolean(cls, x: Optional[bool]) -&gt; bool:\n        ...\n\n    @classmethod\n    @overload\n    def to_boolean(cls, x: int) -&gt; bool:\n        ...\n\n    @classmethod\n    @overload\n    def to_boolean(cls, x: Optional[str]) -&gt; bool:\n        ...\n\n    @classmethod\n    def to_boolean(cls, x: Union[int, str, bool, None]) -&gt; bool:\n        if x is None:\n            return False\n\n        if isinstance(x, bool):\n            return x\n\n        if isinstance(x, int):\n            return x != 0\n\n        if isinstance(x, str):\n            _x = x.lower()\n            return cls.or_args(\n                _x == cls.TRUE, _x == cls.T, _x == cls.Y, _x == cls.YES, _x == cls.ON\n            )\n\n        raise ValueError(\"Unable to convert the value to boolean\")\n\n    @classmethod\n    @overload\n    def parse_bool(\n        cls, value: Optional[int], true_value: Optional[int], false_value: Optional[int]\n    ) -&gt; bool:\n        ...\n\n    @classmethod\n    @overload\n    def parse_bool(\n        cls, value: Optional[str], true_value: Optional[str], false_value: Optional[str]\n    ) -&gt; bool:\n        ...\n\n    @classmethod\n    def parse_bool(\n        cls,\n        value: Optional[Union[int, str]],\n        true_value: Optional[Union[int, str]],\n        false_value: Optional[Union[int, str]],\n    ) -&gt; bool:\n        if value == true_value:\n            return True\n\n        if value == false_value:\n            return False\n\n        raise ValueError(\"value does not match either of true_value or false_value\")\n\n    @classmethod\n    def get_boolean(cls, flag: Optional[bool], default_value: bool = False) -&gt; bool:\n        if flag is None:\n            return default_value\n\n        return flag\n\n    @classmethod\n    @overload\n    def to_bool_object(\n        cls,\n        value: Optional[Union[int]],\n        true_value: Optional[Union[int]],\n        false_value: Optional[Union[int]],\n        none_value: Optional[Union[int]],\n    ) -&gt; Optional[bool]:\n        ...\n\n    @classmethod\n    @overload\n    def to_bool_object(\n        cls,\n        value: Optional[Union[str]],\n        true_value: Optional[Union[str]],\n        false_value: Optional[Union[str]],\n        none_value: Optional[Union[str]],\n    ) -&gt; Optional[bool]:\n        ...\n\n    @classmethod\n    def to_bool_object(\n        cls,\n        value: Optional[Union[int, str]],\n        true_value: Optional[Union[int, str]],\n        false_value: Optional[Union[int, str]],\n        none_value: Optional[Union[int, str]],\n    ) -&gt; Optional[bool]:\n        if value == true_value:\n            return True\n\n        if value == false_value:\n            return False\n\n        if value == none_value:\n            return None\n\n        raise ValueError(\"value does not match either of true_value or false_value or null_value\")\n\n    @classmethod\n    @overload\n    def to_boolean_object(cls, value: Optional[bool]) -&gt; Optional[bool]:\n        ...\n\n    @classmethod\n    @overload\n    def to_boolean_object(cls, value: int) -&gt; Optional[bool]:\n        ...\n\n    @classmethod\n    @overload\n    def to_boolean_object(cls, value: Optional[str]) -&gt; Optional[bool]:\n        ...\n\n    @classmethod\n    def to_boolean_object(cls, value: Union[str, bool, int, None]) -&gt; Optional[bool]:\n        if value is None:\n            return None\n\n        if isinstance(value, bool):\n            return value\n\n        if isinstance(value, int):\n            return value != 0\n\n        if isinstance(value, str):\n            _flag = value.lower()\n            if cls.or_args(\n                _flag == cls.TRUE, _flag == cls.T, _flag == cls.Y, _flag == cls.YES, _flag == cls.ON\n            ):\n                return True\n\n            if cls.or_args(\n                _flag == cls.FALSE,\n                _flag == cls.F,\n                _flag == cls.N,\n                _flag == cls.NO,\n                _flag == cls.OFF,\n            ):\n                return False\n\n            return None\n\n        raise ValueError(\"Unable to parse the argument to boolean\")\n\n    @classmethod\n    def to_int(cls, flag: bool, true_value: int = 1, false_value: int = 0) -&gt; int:\n        return true_value if flag else false_value\n\n    @classmethod\n    def to_int_from_boolean_object(\n        cls, flag: Optional[bool], true_value: int, false_value: int, none_value: int\n    ) -&gt; int:\n        if flag is None:\n            return none_value\n\n        return cls.to_int(flag, true_value, false_value)\n\n    @classmethod\n    def to_int_object_from_boolean_object(\n        cls,\n        flag: Optional[bool],\n        true_value: Optional[int],\n        false_value: Optional[int],\n        none_value: Optional[int],\n    ) -&gt; Optional[int]:\n        if flag is None:\n            return none_value\n\n        return true_value if flag else false_value\n\n    @classmethod\n    def to_str(cls, flag: bool, true_value: str, false_value: str) -&gt; str:\n        return true_value if flag else false_value\n\n    @classmethod\n    def to_str_from_boolean_object(\n        cls, flag: Optional[bool], true_value: str, false_value: str, none_value: str\n    ) -&gt; str:\n        if flag is None:\n            return none_value\n\n        return cls.to_str(flag, true_value, false_value)\n\n    @classmethod\n    def to_str_object_from_boolean_object(\n        cls,\n        flag: Optional[bool],\n        true_value: Optional[str],\n        false_value: Optional[str],\n        none_value: Optional[str],\n    ) -&gt; Optional[str]:\n        if flag is None:\n            return none_value\n\n        return true_value if flag else false_value\n\n    @classmethod\n    def to_str_true_false(cls, flag: Optional[bool]) -&gt; Optional[str]:\n        return cls.to_str_object_from_boolean_object(flag, cls.TRUE, cls.FALSE, None)\n\n    @classmethod\n    def to_str_on_off(cls, flag: Optional[bool]) -&gt; Optional[str]:\n        return cls.to_str_object_from_boolean_object(flag, cls.ON, cls.OFF, None)\n\n    @classmethod\n    def to_str_yes_no(cls, flag: Optional[bool]) -&gt; Optional[str]:\n        return cls.to_str_object_from_boolean_object(flag, cls.YES, cls.NO, None)\n</code></pre>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.F","title":"<code>F: ClassVar[str]</code>","text":"<p>The \"f\" string</p>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.FALSE","title":"<code>FALSE: ClassVar[str]</code>","text":"<p>The \"false\" string</p>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.N","title":"<code>N: ClassVar[str]</code>","text":"<p>The \"n\" string</p>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.NO","title":"<code>NO: ClassVar[str]</code>","text":"<p>The \"no\" string</p>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.OFF","title":"<code>OFF: ClassVar[str]</code>","text":"<p>The \"off\" string</p>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.ON","title":"<code>ON: ClassVar[str]</code>","text":"<p>The \"on\" string</p>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.T","title":"<code>T: ClassVar[str]</code>","text":"<p>The \"t\" string</p>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.TRUE","title":"<code>TRUE: ClassVar[str]</code>","text":"<p>The \"true\" string</p>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.Y","title":"<code>Y: ClassVar[str]</code>","text":"<p>The \"y\" string</p>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.YES","title":"<code>YES: ClassVar[str]</code>","text":"<p>The \"yes\" string</p>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.and_args","title":"<code>and_args(*args)</code>  <code>classmethod</code>","text":"<p>Performs <code>and</code> operation on all the arguments and returns the result</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>bool</code> <p>Boolean Arguments</p> <code>()</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if all the arguments are True, False otherwise</p> Source code in <code>lang/booleanutils.py</code> <pre><code>@classmethod\ndef and_args(cls, *args: bool) -&gt; bool:\n\"\"\"\n    Performs `and` operation on all the arguments and returns the result\n    Args:\n        *args: Boolean Arguments\n\n    Returns:\n        True if all the arguments are True, False otherwise\n    \"\"\"\n    ArrayUtils.require_not_empty(args)\n    for flag in args:\n        ObjectUtils.require_not_none(flag)\n        if cls.is_not_true(flag):\n            return False\n\n    return True\n</code></pre>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.is_false","title":"<code>is_false(flag)</code>  <code>classmethod</code>","text":"<p>Return if an optional flag is <code>False</code> by handling <code>None</code> as False</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>Optional[bool]</code> <p>A boolean object or None</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the flag is False, False otherwise</p> Source code in <code>lang/booleanutils.py</code> <pre><code>@classmethod\ndef is_false(cls, flag: Optional[bool]) -&gt; bool:\n\"\"\"\n    Return if an optional flag is `False` by handling `None` as False\n    Args:\n        flag: A boolean object or None\n\n    Returns:\n        True if the flag is False, False otherwise\n    \"\"\"\n    return flag is False\n</code></pre>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.is_not_false","title":"<code>is_not_false(flag)</code>  <code>classmethod</code>","text":"<p>Negation of <code>is_false</code> method by handling <code>None</code> as False</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>Optional[bool]</code> <p>A boolean flag or None</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the flag is not False, False otherwise</p> Source code in <code>lang/booleanutils.py</code> <pre><code>@classmethod\ndef is_not_false(cls, flag: Optional[bool]) -&gt; bool:\n\"\"\"\n    Negation of [`is_false`][pycommons.lang.booleanutils.BooleanUtils.is_false]\n    method by handling `None` as False\n    Args:\n        flag: A boolean flag or None\n\n    Returns:\n        True if the flag is not False, False otherwise\n    \"\"\"\n    return flag is not False\n</code></pre>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.is_not_true","title":"<code>is_not_true(flag)</code>  <code>classmethod</code>","text":"<p>Negation of <code>is_false</code> method by handling <code>None</code> as False</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>Optional[bool]</code> <p>A boolean flag or None</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the flag is not True, False otherwise</p> Source code in <code>lang/booleanutils.py</code> <pre><code>@classmethod\ndef is_not_true(cls, flag: Optional[bool]) -&gt; bool:\n\"\"\"\n    Negation of [`is_false`][pycommons.lang.booleanutils.BooleanUtils.is_true]\n    method by handling `None` as False\n    Args:\n        flag: A boolean flag or None\n\n    Returns:\n        True if the flag is not True, False otherwise\n    \"\"\"\n    return flag is not True\n</code></pre>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.is_true","title":"<code>is_true(flag)</code>  <code>classmethod</code>","text":"<p>Return if an optional flag is <code>True</code> by handling <code>None</code> as False</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>Optional[bool]</code> <p>A boolean object or None</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the flag is True, False otherwise</p> Source code in <code>lang/booleanutils.py</code> <pre><code>@classmethod\ndef is_true(cls, flag: Optional[bool]) -&gt; bool:\n\"\"\"\n    Return if an optional flag is `True` by handling `None` as False\n    Args:\n        flag: A boolean object or None\n\n    Returns:\n        True if the flag is True, False otherwise\n    \"\"\"\n    return flag is True\n</code></pre>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.negate","title":"<code>negate(flag)</code>  <code>classmethod</code>","text":"<p>Negate a boolean by returning <code>None</code> for <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>Optional[bool]</code> <p>A boolean flag or None</p> required <p>Returns:</p> Type Description <code>Optional[bool]</code> <p>True if False, False if True, None if None</p> Source code in <code>lang/booleanutils.py</code> <pre><code>@classmethod\ndef negate(cls, flag: Optional[bool]) -&gt; Optional[bool]:\n\"\"\"\n    Negate a boolean by returning `None` for `None`.\n    Args:\n        flag: A boolean flag or None\n\n    Returns:\n        True if False, False if True, None if None\n    \"\"\"\n    if flag is None:\n        return None\n    return not flag\n</code></pre>"},{"location":"package/booleanutils/#pycommons.lang.booleanutils.BooleanUtils.or_args","title":"<code>or_args(*args)</code>  <code>classmethod</code>","text":"<p>Performs <code>or</code> operation on all the arguments and returns the result</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>bool</code> <p>Boolean Arguments</p> <code>()</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if any of the arguments are True, False otherwise</p> Source code in <code>lang/booleanutils.py</code> <pre><code>@classmethod\ndef or_args(cls, *args: bool) -&gt; bool:\n\"\"\"\n    Performs `or` operation on all the arguments and returns the result\n    Args:\n        *args: Boolean Arguments\n\n    Returns:\n        True if any of the arguments are True, False otherwise\n    \"\"\"\n    ArrayUtils.require_not_empty(args)\n    for flag in args:\n        ObjectUtils.require_not_none(flag)\n        if flag:\n            return True\n\n    return False\n</code></pre>"},{"location":"package/stringutils/","title":"stringutils","text":""},{"location":"package/stringutils/#pycommons.lang.stringutils.StringUtils","title":"<code> StringUtils            (UtilityClass)         </code>","text":"<p>The StringUtils holds the utility methods for string observation, manipulation, conversion etc. This class is inspired by the <code>StringUtils</code> class in the Apache Commons Lang package. Provides <code>None</code> safe methods to perform operations on <code>str</code> object</p> <p>References</p> <p>https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html</p> Source code in <code>lang/stringutils.py</code> <pre><code>class StringUtils(UtilityClass):\n\"\"\"\n    The StringUtils holds the utility methods for string observation,\n    manipulation, conversion etc. This class is inspired by the `StringUtils`\n    class in the Apache Commons Lang package. Provides `None` safe methods\n    to perform operations on `str` object\n\n    References:\n        https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html\n    \"\"\"\n\n    EMPTY: str = \"\"\n\n    @classmethod\n    def abbreviate(\n        cls,\n        char_sequence: Optional[str],\n        abbrev_marker: Optional[str] = \"...\",\n        offset: int = 0,\n        max_width: int = -1,\n    ) -&gt; Optional[str]:\n        if cls.is_not_empty(char_sequence) and cls.EMPTY == abbrev_marker and max_width &gt; 0:\n            return typing.cast(str, char_sequence)[:max_width]\n\n        if cls.is_any_empty(char_sequence, abbrev_marker):\n            return char_sequence\n\n        char_sequence = typing.cast(str, abbrev_marker)\n        abbrev_marker = typing.cast(str, abbrev_marker)\n        abbrev_marker_length = len(abbrev_marker)\n        min_abbrev_width = abbrev_marker_length + 1\n        min_abbrev_width_offset = abbrev_marker_length + abbrev_marker_length + 1\n\n        if max_width == -1:\n            max_width = len(char_sequence) - abbrev_marker_length\n\n        if max_width &lt; min_abbrev_width:\n            raise ValueError(f\"Minimum abbreviation width is {min_abbrev_width}\")\n\n        str_len = len(char_sequence)\n        if str_len &lt;= max_width:\n            return char_sequence\n\n        offset = min(offset, str_len)\n\n        if str_len - offset &lt; max_width - abbrev_marker_length:\n            offset = str_len - (max_width - abbrev_marker_length)\n\n        if offset &lt;= abbrev_marker_length + 1:\n            return char_sequence[: max_width - abbrev_marker_length] + abbrev_marker\n\n        if max_width &lt; min_abbrev_width_offset:\n            raise ValueError(f\"Minimum abbreviation width with offset is {min_abbrev_width_offset}\")\n        return char_sequence[offset : offset + max_width - abbrev_marker_length] + abbrev_marker\n\n    @classmethod\n    def abbreviate_middle(\n        cls, char_sequence: Optional[str], middle: Optional[str] = \"...\", length: int = 5\n    ) -&gt; Optional[str]:\n        if (\n            not cls.is_any_empty(char_sequence, middle)\n            and len(typing.cast(str, char_sequence)) &gt; length &gt;= len(typing.cast(str, middle)) + 2\n        ):\n            middle = typing.cast(str, middle)\n            char_sequence = typing.cast(str, char_sequence)\n\n            target_string = length - len(middle)\n            start_offset = target_string // 2 + target_string % 2\n            end_offset = len(char_sequence) - target_string // 2\n            return char_sequence[:start_offset] + middle + char_sequence[end_offset:]\n\n        return char_sequence\n\n    @classmethod\n    def contains(cls, char_sequence: Optional[str], search_string: Optional[str]) -&gt; bool:\n        if char_sequence is not None and search_string is not None:\n            search_length: int = len(search_string)\n            max_iterations: int = len(char_sequence) - search_length\n\n            for i in range(0, max_iterations + 1):\n                if cls.region_matches(char_sequence, False, i, search_string, 0, search_length):\n                    return True\n        return False\n\n    @classmethod\n    def contains_any(cls, char_sequence: Optional[str], *search_strings: str) -&gt; bool:\n        if char_sequence is not None and ArrayUtils.is_not_empty(search_strings):\n            for search_string in search_strings:\n                if cls.contains(char_sequence, search_string):\n                    return True\n        return False\n\n    @classmethod\n    def contains_ignore_case(\n        cls, char_sequence: Optional[str], search_string: Optional[str]\n    ) -&gt; bool:\n        if char_sequence is not None and search_string is not None:\n            search_length: int = len(search_string)\n            max_iterations: int = len(char_sequence) - search_length\n\n            for i in range(0, max_iterations + 1):\n                if cls.region_matches(char_sequence, True, i, search_string, 0, search_length):\n                    return True\n        return False\n\n    @classmethod\n    def get_first_non_blank(cls, *args: Optional[str]) -&gt; Optional[str]:\n        if ArrayUtils.is_empty(args):\n            return None\n\n        for char_sequence in args:\n            if not cls.is_blank(char_sequence):\n                return char_sequence\n\n        return None\n\n    @classmethod\n    def get_first_non_empty(cls, *args: Optional[str]) -&gt; Optional[str]:\n        if ArrayUtils.is_empty(args):\n            return None\n\n        for char_sequence in args:\n            if not cls.is_empty(char_sequence):\n                return char_sequence\n\n        return None\n\n    @classmethod\n    def get_bytes(cls, char_sequence: Optional[str], encoding: str = \"utf-8\") -&gt; Optional[bytes]:\n        if char_sequence is None:\n            return None\n        return char_sequence.encode(encoding)\n\n    @classmethod\n    def get_digits(cls, char_sequence: Optional[str]) -&gt; str:\n        if cls.is_empty(char_sequence):\n            return cls.EMPTY\n\n        digits: List[str] = []\n        for c in typing.cast(str, char_sequence):\n            if CharUtils.is_digit(c):\n                digits.append(c)\n\n        return cls.EMPTY.join(digits)\n\n    @classmethod\n    def get_if_blank(cls, char_sequence: Optional[str], default_supplier: Supplier[str]) -&gt; str:\n        if cls.is_not_blank(char_sequence):\n            return typing.cast(str, char_sequence)\n        return default_supplier.get()\n\n    @classmethod\n    def get_if_empty(cls, char_sequence: Optional[str], default_supplier: Supplier[str]) -&gt; str:\n        if cls.is_not_empty(char_sequence):\n            return typing.cast(str, char_sequence)\n        return default_supplier.get()\n\n    @classmethod\n    def is_all_lower_case(cls, char_sequence: Optional[str]) -&gt; bool:\n        if char_sequence is None:\n            return False\n\n        for char in char_sequence:\n            if not CharUtils.is_lowercase(char):\n                return False\n        return True\n\n    @classmethod\n    def is_all_upper_case(cls, char_sequence: Optional[str]) -&gt; bool:\n        if char_sequence is None:\n            return False\n\n        for char in char_sequence:\n            if not CharUtils.is_uppercase(char):\n                return False\n        return True\n\n    @classmethod\n    def is_alpha(cls, char_sequence: Optional[str]) -&gt; bool:\n        if char_sequence is None:\n            return False\n\n        for char in char_sequence:\n            if not CharUtils.is_letter(char):\n                return False\n        return True\n\n    @classmethod\n    def is_alphanumeric(cls, char_sequence: Optional[str]) -&gt; bool:\n        if char_sequence is None:\n            return False\n\n        for char in char_sequence:\n            if not CharUtils.is_letter_or_digit(char):\n                return False\n        return True\n\n    @classmethod\n    def is_alphanumeric_space(cls, char_sequence: Optional[str]) -&gt; bool:\n        if char_sequence is None:\n            return False\n\n        for char in char_sequence:\n            if not CharUtils.is_letter_or_digit(char) and CharUtils.is_equal(\n                char, str(CharUtils.ASCII_SPACE)\n            ):\n                return False\n        return True\n\n    @classmethod\n    def is_alpha_space(cls, char_sequence: Optional[str]) -&gt; bool:\n        if char_sequence is None:\n            return False\n\n        for char in char_sequence:\n            if not CharUtils.is_letter(char) and CharUtils.is_equal(\n                char, str(CharUtils.ASCII_SPACE)\n            ):\n                return False\n        return True\n\n    @classmethod\n    def is_any_blank(cls, *args: Optional[str]) -&gt; bool:\n        if ArrayUtils.is_empty(args):\n            return False\n\n        for char_sequence in args:\n            if cls.is_blank(char_sequence):\n                return True\n        return False\n\n    @classmethod\n    def is_any_empty(cls, *args: Optional[str]) -&gt; bool:\n        if ArrayUtils.is_empty(args):\n            return False\n\n        for char_sequence in args:\n            if cls.is_empty(char_sequence):\n                return True\n        return False\n\n    @classmethod\n    def is_ascii_printable(cls, char_sequence: Optional[str]) -&gt; bool:\n        if char_sequence is None:\n            return False\n\n        for c in char_sequence:\n            if not CharUtils.is_ascii_printable(cls.to_character(c)):\n                return False\n        return True\n\n    @classmethod\n    def is_blank(cls, char_sequence: Optional[str]) -&gt; bool:\n        length: int = cls.length(char_sequence)\n        if 0 == length:\n            return True\n\n        for char in typing.cast(str, char_sequence):\n            if not CharUtils.is_whitespace(cls.to_character(char)):\n                return False\n        return True\n\n    @classmethod\n    def is_empty(cls, char_sequence: Optional[str]) -&gt; bool:\n        return char_sequence is None or len(char_sequence) == 0\n\n    @classmethod\n    def is_not_blank(cls, char_sequence: Optional[str]) -&gt; bool:\n        return not cls.is_blank(char_sequence)\n\n    @classmethod\n    def is_not_empty(cls, char_sequence: Optional[str]) -&gt; bool:\n        return not cls.is_empty(char_sequence)\n\n    @classmethod\n    def length(cls, char_sequence: Optional[str]) -&gt; int:\n        return 0 if char_sequence is None else len(char_sequence)\n\n    @classmethod\n    def region_matches(\n        cls,\n        char_sequence: str,\n        ignore_case: bool,\n        this_start: int,\n        sub_string: str,\n        start: int,\n        length: int,\n    ) -&gt; bool:\n        index1 = this_start\n        index2 = start\n        tmp_length = length\n        src_length = len(char_sequence) - this_start\n        other_length = len(sub_string) - start\n\n        if this_start &gt;= 0 and start &gt;= 0 and length &gt;= 0:\n            if src_length &gt;= length and other_length &gt;= length:\n                while tmp_length &gt; 0:\n\n                    c1 = char_sequence[index1]\n                    c2 = sub_string[index2]\n\n                    index1 += 1\n                    index2 += 1\n\n                    if c1 != c2:\n                        if not ignore_case:\n                            return False\n\n                        u1 = CharUtils.to_uppercase(c1)\n                        u2 = CharUtils.to_uppercase(c2)\n                        if u1 != u2 and CharUtils.to_lowercase(u1) != CharUtils.to_lowercase(u2):\n                            return False\n\n                    tmp_length -= 1\n                return True\n            return False\n        return False\n\n    @classmethod\n    def to_character(cls, c: Optional[str]) -&gt; Optional[Char]:\n\"\"\"\n        `None` safe conversion of a character to `pycommons.base.Character\n        Args:\n            c:\n\n        Returns:\n\n        \"\"\"\n        if cls.is_empty(c):\n            return None\n\n        return CharUtils.to_character(typing.cast(str, c)[0])\n\n    @classmethod\n    def default_string(cls, char_sequence: Optional[str], default_string: str = EMPTY) -&gt; str:\n\"\"\"\n        Returns the default string if the passed string is `None`.\n\n        Args:\n            char_sequence: The string\n            default_string: Default string to be returned when `char_sequence` is None\n\n        Returns:\n            The `char_sequence` if it's not None, else the default string\n        \"\"\"\n        return char_sequence if char_sequence is not None else default_string\n</code></pre>"},{"location":"package/stringutils/#pycommons.lang.stringutils.StringUtils.default_string","title":"<code>default_string(char_sequence, default_string='')</code>  <code>classmethod</code>","text":"<p>Returns the default string if the passed string is <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>char_sequence</code> <code>Optional[str]</code> <p>The string</p> required <code>default_string</code> <code>str</code> <p>Default string to be returned when <code>char_sequence</code> is None</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>The <code>char_sequence</code> if it's not None, else the default string</p> Source code in <code>lang/stringutils.py</code> <pre><code>@classmethod\ndef default_string(cls, char_sequence: Optional[str], default_string: str = EMPTY) -&gt; str:\n\"\"\"\n    Returns the default string if the passed string is `None`.\n\n    Args:\n        char_sequence: The string\n        default_string: Default string to be returned when `char_sequence` is None\n\n    Returns:\n        The `char_sequence` if it's not None, else the default string\n    \"\"\"\n    return char_sequence if char_sequence is not None else default_string\n</code></pre>"},{"location":"package/stringutils/#pycommons.lang.stringutils.StringUtils.to_character","title":"<code>to_character(c)</code>  <code>classmethod</code>","text":"<p><code>None</code> safe conversion of a character to `pycommons.base.Character</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>Optional[str]</code> required Source code in <code>lang/stringutils.py</code> <pre><code>@classmethod\ndef to_character(cls, c: Optional[str]) -&gt; Optional[Char]:\n\"\"\"\n    `None` safe conversion of a character to `pycommons.base.Character\n    Args:\n        c:\n\n    Returns:\n\n    \"\"\"\n    if cls.is_empty(c):\n        return None\n\n    return CharUtils.to_character(typing.cast(str, c)[0])\n</code></pre>"}]}